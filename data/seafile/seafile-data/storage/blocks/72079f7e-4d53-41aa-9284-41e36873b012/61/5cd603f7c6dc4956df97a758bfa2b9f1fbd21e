## 1 .删除名称空间
### 1.1 删除的时候，出现保持 terminating 状态：
`kubectl edit ns longhorn-system `
```json
修改前：  
"spec": {  
"finalizers": [  
"kubernetes"  
]  
},  
  
修改后：  
"spec": {  
},
```
检查 `kubectl get ns` 应该已经成功删除\
### 1.2 如果不能直接编辑，使用 api 删除
```bash
kubectl get namespace calico-system -o json > tmp.json
按照上方格式编辑文件，然后执行下列命令
kubectl replace --raw "/api/v1/namespaces/calico-system/finalize" -f ./tmp.json
```
>[!info]
>Kubernetes 中的对象删除并不像表面上看起来那么简单，删除对象涉及一系列过程，例如对象的级联和非级联删除，在删除之前检查以确定是否可以安全删除对象等等。这些都是通过称为 Finalizers（终结器）的 API 对象实现的。\
Finalizers 终结器\
Finalizers 是由字符串组成的数组，当 Finalizers 字段中存在元素时，相关资源不允许被删除，Finalizers 是 Kubernetes 资源删除流程中的一种拦截机制，能够让控制器实现异步的删除前（Pre-delete）回调，在对象删除之前执行相应的逻辑。\
Finalizers 可以防止意外删除集群所依赖的、用于正常运作的资源。Kubernetes 中有些原生的资源对象会被自动加上 Finalizers 标签，例如 PVC 和 PV 分别原生自带 kubernetes.io/pvc-protection 和 kubernetes.io/pv-protection 的 Finalizers 标签，以保证持久化存储不被误删，避免挂载了存储的的工作负载产生问题。假如你试图删除一个仍被 Pod 使用的 PVC，该资源不会被立即删除，它将进入 Terminating 状态，直到 PVC 不再挂载到 Pod 上时， Kubernetes 才清除这个对象。\
Kubernetes 对象的删除过程\
当删除一个对象时，其对应的控制器并不会真正执行删除对象的操作，在 Kubernetes 中对象的回收操作是由 GarbageCollectorController （垃圾收集器）负责的，其作用就是当删除一个对象时，会根据指定的删除策略回收该对象及其依赖对象。删除的具体过程如下：\
发出删除命令后 Kubernetes 会将该对象标记为待删除，但不会真的删除对象，具体做法是将对象的 metadata.deletionTimestamp 字段设置为当前时间戳，这使得对象处于只读状态（除了修改 finalizers 字段）。\
当 metadata.deletionTimestamp 字段非空时，负责监视该对象的各个控制器会执行对应的 Finalizer 动作，每个 Finalizer 动作完成后，就会从 Finalizers 列表中删除对应的 Finalizer。
一旦 Finalizers 列表为空时，就意味着所有 Finalizer 都被执行过了，垃圾收集器会最终删除该对象
