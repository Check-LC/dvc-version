# 安装

```shell
apt update
apt install slapd ldap-utils -y
```

安装过程中，系统会要求您选择并确认 LDAP 的管理员密码。您可以在此输入任何内容，因为稍后您就有机会更新密码。
![](attachments/Snipaste_2023-10-18_14-38-12.png)

确认密码，再次输入admin的密码:
![](attachments/Snipaste_2023-10-18_14-45-03.png)

查看ldap信息：
```shell
# slapcat
dn: dc=nodomain
objectClass: top
objectClass: dcObject
objectClass: organization
o: nodomain
dc: nodomain
structuralObjectClass: organization
entryUUID: a575ca8a-01cd-103e-9105-41747a244a73
creatorsName: cn=admin,dc=nodomain
createTimestamp: 20231018064518Z
entryCSN: 20231018064518.694386Z#000000#000#000000
modifiersName: cn=admin,dc=nodomain
modifyTimestamp: 20231018064518Z

dn: cn=admin,dc=nodomain
objectClass: simpleSecurityObject
objectClass: organizationalRole
cn: admin
description: LDAP administrator
userPassword:: e1NTSEF9N251Qy9XR0NHMmdWY0REMVhvYmlRRHJwOCtTK3pDYWg=
structuralObjectClass: organizationalRole
entryUUID: a57629d0-01cd-103e-9106-41747a244a73
creatorsName: cn=admin,dc=nodomain
createTimestamp: 20231018064518Z
entryCSN: 20231018064518.696868Z#000000#000#000000
modifiersName: cn=admin,dc=nodomain
modifyTimestamp: 20231018064518Z
```

该命令查询出的信息位于`/etc/ldap/slapd.d/cn\=config/olcDatabase\=\{1\}mdb.ldif`文件中。

尽管我们刚刚安装了软件包，但我们还是要继续重新配置它。slabd 软件包可以询问许多重要的配置问题，但默认情况下，它们在安装过程中会被跳过。我们只需告诉系统重新配置软件包，就能访问所有提示：
```shell
# dpkg-reconfigure slapd
```

`No`: 如果启用此选项，将不会为您创建初始配置或数据库。忽略 openldap 服务器配置?
![](attachments/Snipaste_2023-10-18_14-50-04.png)

输入 DNS 域名信息:
![](attachments/Snipaste_2023-10-18_14-50-35.png)

输入组织名称:
![](attachments/Snipaste_2023-10-18_14-51-09.png)

输入管理员密码:
![](attachments/Snipaste_2023-10-18_14-51-28.png)

再次确认管理员密码:
![](attachments/Snipaste_2023-10-18_14-51-44.png)

`no`: 清理slapd时是否移除数据库？
![](attachments/Snipaste_2023-10-18_14-52-14.png)

`yes`: 如果启用该选项，维护者脚本会在创建新数据库之前将旧数据库文件移走，移走旧数据库？
![](attachments/Snipaste_2023-10-18_14-52-48.png)

```shell
# slapcat
dn: dc=inboc,dc=net
objectClass: top
objectClass: dcObject
objectClass: organization
o: inboc
dc: inboc
structuralObjectClass: organization
entryUUID: ba7d94fc-01ce-103e-8415-9f5ad1e0692b
creatorsName: cn=admin,dc=inboc,dc=net
createTimestamp: 20231018065303Z
entryCSN: 20231018065303.474325Z#000000#000#000000
modifiersName: cn=admin,dc=inboc,dc=net
modifyTimestamp: 20231018065303Z

dn: cn=admin,dc=inboc,dc=net
objectClass: simpleSecurityObject
objectClass: organizationalRole
cn: admin
description: LDAP administrator
userPassword:: e1NTSEF9YTEyYldMUE8yVlM5WUY2S0VMbG00RnhmaU9DV3RNUnA=
structuralObjectClass: organizationalRole
entryUUID: ba7df000-01ce-103e-8416-9f5ad1e0692b
creatorsName: cn=admin,dc=inboc,dc=net
createTimestamp: 20231018065303Z
entryCSN: 20231018065303.476700Z#000000#000#000000
modifiersName: cn=admin,dc=inboc,dc=net
modifyTimestamp: 20231018065303Z
```

使用 ldapwhoami 测试我们的 LDAP 连接，它将返回我们连接的用户名:
```shell
# ldapwhoami -H ldap:// -x
anonymous

```

匿名是我们期待的结果，因为我们在没有登录 LDAP 服务器的情况下运行了 ldapwhoami。这意味着服务器正在运行并回答查询。接下来，我们将设置一个网络接口来管理 LDAP 数据。

## 步骤 2 - 安装和配置 phpLDAPadmin Web 界面

虽然可以通过命令行管理 LDAP，但大多数用户会发现使用 Web 界面更方便。我们将安装 phpLDAPadmin，这是一个提供此功能的 PHP 应用程序。

Ubuntu 软件源中有一个 phpLDAPadmin 软件包。您可以使用 apt-get 安装它：
```shell
# apt update
# apt install phpldapadmin -y
```

这将安装应用程序，启用必要的 Apache 配置，并重新加载 Apache。

网络服务器现在已配置好为应用程序提供服务，但我们还需要做一些额外的更改。我们需要配置 phpLDAPadmin 使用我们的域，并且不自动填写 LDAP 登录信息。

首先，在文本编辑器中以 root 权限打开主配置文件：
```shell
# vim /etc/phpldapadmin/config.php
```

查找以 `$servers->setValue('server','name'` 开头的一行，这一行是 LDAP 服务器的显示名称，网络接口会使用它来显示服务器的标题和信息。请在此选择合适的名称：
```shell
# /etc/phpldapadmin/config.php
$servers->setValue('server','name','ldap.inboc.net');
```

接下来，向下移动到 `$servers->setValue('server','base')`一行。该配置告诉 phpLDAPadmin LDAP 层次结构的根。这是基于我们在重新配置 slapd 软件包时输入的值。在我们的示例中，我们选择了 `inboc.net`，我们需要将其转换为 LDAP 语法，将每个域组件（所有非点）放入 dc= 符号中：
```
$servers->setValue('server','base',array('dc=inboc,dc=net'));
```

现在找到登录 bind_id 配置行，并在该行开头用 # 号注释掉：
```shell
# /etc/phpldapadmin/config.php
$servers->setValue('login','bind_id','cn=admin,dc=inboc,dc=net');
```

该选项会在网络界面中预填管理员登录信息。如果我们的 phpLDAPadmin 页面可以公开访问，我们就不应该共享这些信息。

最后，我们需要调整的是控制 phpLDAPadmin 某些警告信息可见性的设置。默认情况下，应用程序会显示大量有关模板文件的警告信息。这些信息对我们当前使用软件没有任何影响。我们可以通过搜索 `hide_template_warning` 参数来隐藏它们，取消注释包含该参数的行并将其设置为 `true`：
```shell
$config->custom->appearance['hide_template_warning'] = true;
```

这是我们需要调整的最后一项内容。保存并关闭文件即可完成。我们不需要重启任何程序就能使更改生效。接下来我们通过网址 `[phpLDAPadmin (1.2.2) -](http://10.13.3.101/phpldapadmin/)` 登录 phpLDAPadmin。

phpLDAPadmin 登录页面将加载。单击页面左侧菜单中的登录链接。将显示登录表单：
![](attachments/Snipaste_2023-10-18_15-22-13.png)

此时，您已登录到 phpLDAPadmin 界面。您可以添加用户、组织单位、组和关系。

LDAP 的数据结构和目录层次结构非常灵活。您可以创建任何您想要的结构，还可以为它们的交互方式创建规则。

## 步骤 3 - 配置 StartTLS LDAP 加密

虽然我们已经对网页界面进行了加密，但外部 LDAP 客户端仍在连接服务器，并以纯文本形式传递信息。让我们使用 Let's Encrypt SSL 证书为 LDAP 服务器添加加密功能。

### 复制 Let's Encrypt 证书

因为slapd守护进程是以openldap用户身份运行的，而Let's Encrypt证书只能由根用户读取，所以我们需要做一些调整来允许slapd访问证书。我们将创建一个简短的脚本，把证书复制到 /etc/ssl/，这是 SSL 证书和密钥的标准系统目录。之所以要编写脚本而不是手动输入命令，是因为每当 Let's Encrypt 更新证书时，我们都需要自动重复这一过程。稍后我们将更新 certbot cron 作业，以启用此功能。

首先，为 shell 脚本新建一个文本文件：
```shell
# vim /usr/local/bin/renew.sh
```

这将打开一个空白文本文件。粘贴以下脚本。确保更新 SITE=example.com 部分，以反映 Let's Encrypt 证书的存储位置。你可以用 `sudo ls /etc/letsencrypt/live` 列出证书目录，找到正确的值。
```
#!/bin/sh

SITE=inboc.net

# move to the correct let's encrypt directory
cd /etc/letsencrypt/live/$SITE

# copy the files
cp cert.pem /etc/ssl/certs/$SITE.cert.pem
cp fullchain.pem /etc/ssl/certs/$SITE.fullchain.pem
cp privkey.pem /etc/ssl/private/$SITE.privkey.pem

# adjust permissions of the private key
chown :ssl-cert /etc/ssl/private/$SITE.privkey.pem
chmod 640 /etc/ssl/private/$SITE.privkey.pem

# restart slapd to load new certificates
systemctl restart slapd
```

这个脚本会移动到 Let's Encrypt 证书目录，复制文件到 /etc/ssl，然后更新私钥的权限，使系统的 ssl-cert 组能读取它。它还会重启 slapd，以确保从 certbot 更新 cron 作业中运行此脚本时能加载新证书。

保存并关闭文件，然后使其可执行：
```
chmod u+x /usr/local/bin/renew.sh
```

然后用 sudo 运行脚本：
```
# /usr/local/bin/renew.sh
```

在 /etc/ssl 中列出新文件，以验证脚本是否正常运行：
```
# ls -al /etc/ssl/{certs,private}/inboc.net*
```

ls 将打印这三个文件的详细信息。确认所有权和权限是否正确：
```shell
-rw-r--r-- 1 root root     5623 Oct 18 16:00 /etc/ssl/certs/inboc.net.cert.pem
-rw-r--r-- 1 root root     5623 Oct 18 16:00 /etc/ssl/certs/inboc.net.fullchain.pem
-rw-r----- 1 root ssl-cert 1679 Oct 18 16:00 /etc/ssl/private/inboc.net.privkey.pem
```

接下来我们用 certbot 自动执行。

### 更新 Certbot 更新 Cron 作业

我们需要更新 certbot cron 作业，以便在证书更新时运行此脚本：
```shell
# crontab -e
```

你应该已经有了一个 certbot 更新行。添加下面突出显示的部分：
```shell
15 3 * * * /usr/bin/certbot renew --quiet --renew-hook /usr/local/bin/renew.sh
```

保存并关闭 crontab。现在，每当 certbot 更新证书时，我们的脚本就会运行，复制文件、调整权限并重启 slapd 服务器。

### 配置 slapd 以提供安全连接

我们需要将 openldap 用户添加到 ssl-cert 组，这样 slapd 才能读取私钥：
```shell
usermod -aG ssl-cert openldap
```

重启slapd，让它接收新组：
```shell
# systemctl restart slapd
```

最后，我们需要配置 slapd 以实际使用这些证书和密钥。为此，我们将所有配置更改放入 LDIF 文件（LDIF 是 LDAP 数据交换格式的缩写），然后使用 ldapmodify 命令将更改加载到 LDAP 服务器中。

打开一个新的 LDIF 文件：

```shell
cd ~
touch ssl.ldif
```

这将打开一个空白文件。将以下内容粘贴到文件中，更新文件名以反映您的域名：
```shell
dn: cn=config
changetype: modify
replace: olcTLSCACertificateFile
olcTLSCACertificateFile: /etc/ssl/certs/inboc.net.fullchain.pem
-
replace: olcTLSCertificateFile
olcTLSCertificateFile: /etc/ssl/certs/inboc.net.cert.pem
-
replace: olcTLSCertificateKeyFile
olcTLSCertificateKeyFile: /etc/ssl/private/inboc.net.privkey.pem
```

保存并关闭文件，然后使用 ldapmodify 应用更改：
```shell
ldapmodify -H ldapi:// -Y EXTERNAL -f ssl.ldif
```

输出:
```shell
SASL/EXTERNAL authentication started
SASL username: gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth
SASL SSF: 0
modifying entry "cn=config"
```

我们不需要重新加载 slapd 来加载新证书，这是用 ldapmodify 更新配置时自动发生的。再运行一次 ldapwhoami 命令进行验证。这次我们需要使用正确的主机名，并添加 `-ZZ` 选项以强制安全连接：
```shell
ldapwhoami -H ldap://ldap01.inboc.net -x -ZZ
```

> [!warning] 注意
> LDAP的地址 `ldap01.inboc.net` 需要在运行 `ldapwhoami` 指令的服务器上进行解析方可。  

使用安全连接时，我们需要完整的主机名，因为客户端会检查主机名是否与证书上的主机名一致。这样可以防止中间人攻击，即攻击者可以拦截你的连接并冒充你的服务器。

ldapwhoami 命令应返回匿名，且无错误。我们已经成功加密了 LDAP 连接。
```shell
# ldapwhoami -H ldap://ldap01.inboc.net -x -ZZ
anonymous
```

# 相关指令

命令的Option就不再分命令来介绍，常用的Option的信息和用途整理如下：

|Option|说明|
|---|---|
|-H|ldapuri，格式为ldap://机器名或者IP:端口号，不能与-h和-p同时使用|
|-h|LDAP服务器IP或者可解析的hostname，与-p可结合使用，不能与-H同时使用|
|-p|LDAP服务器端口号，与-h可结合使用，不能与-H同时使用|
|-x|使用简单认证方式|
|-D|所绑定的服务器的DN|
|-w|绑定DN的密码，与-W二者选一|
|-W|不输入密码，会交互式的提示用户输入密码，与-w二者选一|
|-c|出错后忽略当前错误继续执行，缺省情况下遇到错误即终止|
|-n|模拟操作但并不实际执行，用于验证，常与-v一同使用进行问题定位|
|-v|显示详细信息|
|-d|显示debug信息，可设定级别|
|-e|设置客户端证书|
|-E|设置客户端私钥|


# 配置

## 创建管理员账号

创建olcRootDN作为管理员账号:
```
dn: olcDatabase={1}mdb,cn=config
changetype: modify
replace: olcSuffix
olcSuffix: dc=inboc,dc=net
-
replace: olcRootDN
olcRootDN: cn=admin,dc=inboc,dc=net
-
replace: olcRootPW
olcRootPW: {SSHA}dHT6B0867jI4xK9jA6ObsJPnL5GTTlwX
```

- 修改olcRootDN， 设置为我们的admin: cn=admin,dc=inboc,dc=net
- 修改olcSuffix， 设置为我们的域名dc=inboc,dc=net
- 修改olcRootPW， 设置我们的admin密码, 这个需要加密，所以暂时放一个占位符，等下替换
- changetype变更类型， replace表示替换， add表示增加。

ldapmodify 更新命令， `-H`指定host，这里 `ldapi:///`  表示IPC (Unix-domain socket)协议， `-f`指定变更的内容。
```shell
ldapmodify -Q -Y EXTERNAL -H ldapi:/// -f tmp.ldif
```

我们可以通过search语法来确定账号密码是否正确：
```shell
ldapsearch -H ldapi:/// -D "cn=admin,dc=inboc,dc=net" -w Inboc@2020
```

- ldapsearch 查询语法， `-H`指定host， `-D`指定admin的账号，即rootdn, `-w`指定密码, `-x`启用认证

## 组织管理

### 添加组织

有了管理员，还需要配置组织结构 organization.ldif。在这之前，我们需要导入一些模板。schema类似数据库表定义，  
定义了字段名称和类型。

schema地址：
```bash
/etc/openldap/schema
```

默认安装加载了`core.ldif` , 我们现在加载几个想要的schema:
```perl
ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/cosine.ldif 
ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/nis.ldif 
ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/inetorgperson.ldif 
```

然后，创建文件 organization.ldif
```shell
dn: ou=inboc,dc=inboc,dc=net
objectClass: organizationalUnit
ou: inboc

dn: ou=inboc-sys,ou=inboc,dc=inboc,dc=net
objectClass: organizationalUnit
ou: inboc-sys
```

使用`ldapadd`添加base:
```csharp
ldapadd -x -D cn=admin,dc=inboc,dc=net -w Inboc@2020 -f organization.ldif 
```

### 添加其他的ou

创建一个 organization.ldif文件，内容如下：
```shell
dn: ou=inboc-dev,ou=inboc,dc=inboc,dc=net
objectClass: organizationalUnit
ou: inboc-dev

dn: ou=inboc-bod,ou=inboc,dc=inboc,dc=net
objectClass: organizationalUnit
ou: inboc-bod

dn: ou=inboc-bus,ou=inboc,dc=inboc,dc=net
objectClass: organizationalUnit
ou: inboc-bus

dn: ou=inboc-ops,ou=inboc,dc=inboc,dc=net
objectClass: organizationalUnit
ou: inboc-ops

dn: ou=inboc-vpn,ou=inboc,dc=inboc,dc=net
objectClass: organizationalUnit
ou: inboc-vpn
```

执行 ldapadd 命令添加文件中的ou：
```shell
ldapadd -x -D "cn=admin,dc=inboc,dc=net" -w Inboc@2020 -f base.ldif
```

### 查看组织

使用`ldapsearch`来检查内容:
```shell
ldapsearch -x -D cn=admin,dc=inboc,dc=net -w Inboc@2020 -b "dc=inboc,dc=net"
```

- `-x` 启用认证
- `-D` bind admin的dn
- `-w` admin的密码
- `-b` basedn, 查询的基础dn
- 可以看到中文被替换成hash, 后面可以通过其他方式看到

### 删除组织

使用 ldapdelete 命令删除组织单元，但需要注意的是，在删除组织但是之前必须先删除从属单元：
```shell
ldapdelete -x -D "cn=admin,dc=inboc,dc=net" -w Inboc@2020 "ou=inboc-sys,ou=inboc,dc=inboc,dc=net"
```

### 修改组织

```shell
dn: ou=inboc-test,ou=inboc,dc=inboc,dc=net
changetype: modify
replace: ou
ou: inboc-test01
```

执行修改命令:
```shell
ldapmodify -x -D "cn=admin,dc=inboc,dc=net" -w Inboc@2020 -f base.ldif
```

> [!danger] 未实现
> 建议创建新的ou，在将以前ou的数据迁移到新的ou中。

！！创建posixgroup会有一个memberuid，这和memberof是什么区别


## 用户管理

### 添加用户

ou并不能当做分组，而仅仅是组织架构的一个单元。ldap的分组都是通过单独的group来实现的。

**添加人员**

添加人员对应的是树的叶子节点，使用的`oebjectClass：inetOrgPerson`。

添加组织部门对应的是目录，使用的`objectClass: organizationalUnit`.

我们要把人员添加到`ou=inboc-sys,ou=inboc,dc=inboc,dc=net`下。

创建 adduser.ldif: 
Inboc@2020
```shell
dn: cn=yu.zheng,ou=inboc-bod,ou=inboc,dc=inboc,dc=net
changetype: add
objectClass: inetOrgPerson
cn: yu.zheng
userPassword: {SSHA}W4DSQvcToeOeTJB+6W5fCZmz4PqrmwQs
departmentNumber: 1
sn: Zheng
title: 董事长
mail: yu.zheng@inboc.net
uid: 10000
displayName: 郑羽

dn: cn=jian.xie,ou=inboc-sys,ou=inboc,dc=inboc,dc=net
changetype: add
objectClass: inetOrgPerson
cn: jian.xie
userPassword: {SSHA}W4DSQvcToeOeTJB+6W5fCZmz4PqrmwQs
departmentNumber: 1
sn: Xie
title: 系统运维工程师
mail: jian.xie@inboc.net
uid: 10001
displayName: 谢建

dn: cn=cheng.chen,ou=inboc-dev,ou=inboc,dc=inboc,dc=net
changetype: add
objectClass: inetOrgPerson
cn: cheng.chen
userPassword: {SSHA}W4DSQvcToeOeTJB+6W5fCZmz4PqrmwQs
departmentNumber: 1
sn: Chen
title: Python开发工程师
mail: cheng.chen@inboc.net
uid: 10002
displayName: 陈成

dn: cn=minghong.sun,ou=inboc-bus,ou=inboc,dc=inboc,dc=net
changetype: add
objectClass: inetOrgPerson
cn: minghong.sun
userPassword: {SSHA}W4DSQvcToeOeTJB+6W5fCZmz4PqrmwQs
departmentNumber: 1
sn: Sun
title: 财务
mail: minghong.sun@inboc.net
uid: 10003
displayName: 孙铭泓

dn: cn=binchao.tang,ou=inboc-sys,ou=inboc,dc=inboc,dc=net
changetype: add
objectClass: inetOrgPerson
cn: binchao.tang
userPassword: {SSHA}W4DSQvcToeOeTJB+6W5fCZmz4PqrmwQs
departmentNumber: 1
sn: Tang
title: 运维工程师
mail: binchao.tang@inboc.net
uid: 10004
displayName: 唐斌朝

dn: cn=chao.long,ou=inboc-sys,ou=inboc,dc=inboc,dc=net
changetype: add
objectClass: inetOrgPerson
cn: chao.long
userPassword: {SSHA}W4DSQvcToeOeTJB+6W5fCZmz4PqrmwQs
departmentNumber: 1
sn: Long
title: 运维工程师
mail: chao.long@inboc.net
uid: 10005
displayName: 龙超

dn: cn=xiaofeng.li,ou=inboc-dev,ou=inboc,dc=inboc,dc=net
changetype: add
objectClass: inetOrgPerson
cn: xiaofeng.li
userPassword: {SSHA}W4DSQvcToeOeTJB+6W5fCZmz4PqrmwQs
departmentNumber: 1
sn: Li
title: Python开发工程师
mail: xiaofeng.li@inboc.net
uid: 10006
displayName: 李晓凤

dn: cn=xujun.luo,ou=inboc-dev,ou=inboc,dc=inboc,dc=net
changetype: add
objectClass: inetOrgPerson
cn: xujun.luo
userPassword: xujun.luo@inboc.net
departmentNumber: 1
sn: Luo
title: Python开发工程师
mail: xujun.luo@inboc.net
uid: 10007
displayName: 罗绪军
```

使用`ldapadd`来添加我们的用户:
```shell
ldapadd -x -D cn=admin,dc=inboc,dc=net -w Inboc@2020 -f adduser.ldif
```

### 查询用户信息

指定唯一id来查询某个用户，比如cn唯一，则
```shell
ldapsearch -x -D cn=admin,dc=inboc,dc=net -w Inboc@2020 -b "dc=inboc,dc=net" "cn=jian.xie"
```

和前面的示例相比，多了一个参数`filter`
```shell
ldapsearch -x -D "admin的dn" -w "admin的密码" -b "basedn, 最外层的分组" "search filter:"
```

还可以指定返回的字段:
```shell
ldapsearch -x -D cn=admin,dc=inboc,dc=net -w Inboc@2020 -b "ou=inboc-sys,ou=inboc,dc=inboc,dc=net" cn uid displayName
```

在配置第三方认证的时候，比如[airflow](https://github.com/apache/airflow/blob/master/airflow/contrib/auth/backends/ldap_auth.py), 就是通过这样userfilter来search用户的。

### 修改用户信息

```shell
dn: cn=jian.xie,ou=inboc-sys,ou=inboc,dc=inboc,dc=net
changetype: modify
replace: uid
uid: jian.xiexie
```

执行修改命令:
```shell
ldapmodify -x -D "cn=admin,dc=inboc,dc=net"  -w Inboc@2020 -f <ldif_file>
```

### 迁移用户

```shell
dn: cn=jian.xie,ou=inboc-sys,ou=inboc,dc=inboc,dc=net
changetype: modrdn
newrdn: cn=jian.xie
deleteoldrdn: 1
newsuperior: ou=inboc-dev,ou=inboc,dc=inboc,dc=net
```

执行命令进行修改:
```shell
ldapmodify -x -D "cn=admin,dc=inboc,dc=net" -w Inboc@2020 -f base.ldif
```

### 删除用户

```
ldapdelete -x -D "cn=admin,dc=inboc,dc=net" -w Inboc@2020 "cn=jian.xie,ou=inboc-sys,ou=inboc,dc=inboc,dc=net"
ldapdelete -x -D "cn=admin,dc=inboc,dc=net" -w Inboc@2020 "cn=binchao.tang,ou=inboc-sys,ou=inboc,dc=inboc,dc=net"
ldapdelete -x -D "cn=admin,dc=inboc,dc=net" -w Inboc@2020 "cn=chao.long,ou=inboc-sys,ou=inboc,dc=inboc,dc=net"
ldapdelete -x -D "cn=admin,dc=inboc,dc=net" -w Inboc@2020 "cn=minghong.sun,ou=inboc-bus,ou=inboc,dc=inboc,dc=net"
ldapdelete -x -D "cn=admin,dc=inboc,dc=net" -w Inboc@2020 "cn=cheng.chen,ou=inboc-dev,ou=inboc,dc=inboc,dc=net"
ldapdelete -x -D "cn=admin,dc=inboc,dc=net" -w Inboc@2020 "cn=xiaofeng.li,ou=inboc-dev,ou=inboc,dc=inboc,dc=net"
ldapdelete -x -D "cn=admin,dc=inboc,dc=net" -w Inboc@2020 "cn=xujun.luo,ou=inboc-dev,ou=inboc,dc=inboc,dc=net"
ldapdelete -x -D "cn=admin,dc=inboc,dc=net" -w Inboc@2020 "cn=yu.zheng,ou=inboc-bod,ou=inboc,dc=inboc,dc=net"
```

## 用户密码管理
### 添加用户密码

刚才添加用户太快，忘记添加用户密码了。这就涉及到添加用户的同时指定密码和admin修改密码以及用户、自己修改密码三个情况了。

**添加用户的时候指定密码**
创建文件addone.ldif
```avrasm
dn: cn=binchao.tang,ou=inboc-sys,ou=inboc,dc=inboc,dc=net
changetype: add
objectClass: inetOrgPerson
cn: binchao.tang
userPassword: 123456
departmentNumber: 3
sn: Tang
title: 部署运维工程师
mail: binchao.tang@inboc.net
uid: 10004
displayName: 唐斌朝
```

执行添加
```armasm
ldapadd -x -D cn=admin,dc=inboc,dc=net -w Inboc@2020 -f addone.ldif
```

查询验证
```shell
ldapsearch -x -D cn=admin,dc=inboc,dc=net -w Inboc@2020 -b dc=inboc,dc=net "cn=hr-*"
```

可以看到，filter里可以使用通配符。并且，用户密码被加密了。

我们前文说，第三方系统第一步通过search拿到dn，也就是上面这一步。然后第二个是验证密码，验证密码是怎么做的呢？直接通过search语法连接ldap，通过则证明密码正确。
```shell
ldapsearch -x -D cn=binchao.tang,ou=inboc-sys,ou=inboc,dc=inboc,dc=net -w Inboc@2020
```

### 修改用户密码

管理员权限最大，可以修改任意密码。使用 ldapmodify

创建文件updatepass.ldif
```avrasm
dn: cn=jian.xie,ou=inboc-sys,ou=inboc,dc=inboc,dc=net
changetype: modify
replace: userPassword
userPassword: 123456
```

执行修改
```css
ldapmodify -a -H ldap://ldap01.inboc.net -D "cn=admin,dc=inboc,dc=net" -w Inboc@2020 -f updatepass.ldif 
```

查询确认
```shell
ldapsearch -x -D cn=jian.xie,ou=inboc-sys,ou=inboc,dc=inboc,dc=net -w 123456 -b dc=inboc,dc=net "cn=jian.xie"
```

可以确认密码修改成功了，同时也暴露了一个问题，任意一个人都可以bind登录，然后查询所有用户的信息。后面我  
们将关注acl权限问题，让每个人只能查询自己的信息，让指定的group可以查询所有人的信息。

**注意到，我们使用的明文作为密码存储， 这样的传输方式是不推荐的**， 可以使用sha1来存储。
```shell
slappasswd -s Inboc@2020
{SSHA}W4DSQvcToeOeTJB+6W5fCZmz4PqrmwQs

dn: cn=jian.xie,ou=inboc-sys,ou=inboc,dc=inboc,dc=net
changetype: modify
replace: userPassword
userPassword: {SSHA}jteYjBHGrkchBthU55RUukUlQOKMPPJK

# slappasswd -h {sha} -s ryanmiao
{SHA}vMV4cx3BhPVf0dRvEur3NOWIDEw=
# slappasswd -h {md5} -s ryanmiao
{MD5}J3sqNCJFas5wgycX4lJPsg==

或者sha1
userPassword: {SHA}vMV4cx3BhPVf0dRvEur3NOWIDEw=
```

值得注意的是sha1的结果并不是通常我们用的hex结果，而是通过utf8转换的：
```java
public static String sha1(String str)
    throws NoSuchAlgorithmException, UnsupportedEncodingException {
    if (null == str || str.length() == 0) {
        return null;
    }
    MessageDigest mdTemp = MessageDigest.getInstance("SHA1");
    mdTemp.update(str.getBytes("UTF-8"));
    byte[] md = mdTemp.digest();

    return "{SHA}" + Utf8.decode(java.util.Base64.getEncoder().encode(md));
}
```

前面提到用户已知个人密码的情况下，如何自己修改密码。
```bash
ldappasswd -x -h 172.17.0.2 -p 389 -D "cn=Barbara Jensen,dc=example,dc=org" -w VSzhfbwA -s 123456
```

我们先不关注这种行为吧，默认所有第三方系统只有登录权限。关于组织架构的维护，即ldap组织的更新，我们采用  
其他的方案去管理，ldap只是用来辅助第三方登录的。即，其他系统想要修改密码之类的，统一到我们的用户中心服务  
去修改变更，用户中心负责把信息同步给ldap。

## 添加组Group

ldap的group是一种单独的类型`objectClass: groupOfNames`，有个字段叫做member, value就是entry的dn。如此， 实现了group-user的映射关系。

我们可以通过group来查询member，然而，并不能通过user直接获取到group。这在配置第三方系统的时候，没办法做group认证， 比如airflow要求输入group filter, 默认通过memberof的属性值来获取group。所以，理论上user应该有个字段叫做memberof,  value是group。

大家可能会觉得dn已经很明显的分组了好吧，为啥还要这么复杂。事实上，ldap也提供了Reverse Group Membership Maintenance。由系统来维护二者的映射关系。即
- group添加member的时候会自动给对应的entry添加memberof字段
- 当删除entry的时候，也会从group里删除member字段

这个需要单独配置，默认是不支持的。

### 添加memberof模块

创建add_module_group.sh
```makefile
dn: cn=module,cn=config
cn: module
objectClass: olcModuleList
olcModulePath: /usr/lib64/openldap

dn: cn=module{0},cn=config
changetype: modify
add: olcModuleLoad
olcModuleLoad: memberof.la
```

执行添加
```shell
ldapadd -Q -Y EXTERNAL -H ldapi:/// -f  add_module_group.sh 
```

创建add_group_objectclass.ldif
```shell
dn: olcOverlay=memberof,olcDatabase={1}mdb,cn=config
objectClass: olcConfig
objectClass: olcMemberOf
objectClass: olcOverlayConfig
objectClass: top
olcOverlay: memberof
olcMemberOfDangling: ignore
olcMemberOfRefInt: TRUE
olcMemberOfGroupOC: groupOfNames
olcMemberOfMemberAD: member     
olcMemberOfMemberOfAD: memberOf
```

执行添加
```shell
ldapadd -Q -Y EXTERNAL -H ldapi:/// -f  add_group_objectclass.ldif
```

### 添加一个group

创建 addgroup.ldif
```shell
dn: cn=inboc-sys-admin,ou=inboc-sys,ou=inboc,dc=inboc,dc=net
objectClass: groupOfNames
cn: inboc-sys-admin
member: cn=jian.xie,ou=inboc-sys,ou=inboc,dc=inboc,dc=net

dn: cn=inboc-sys-senior,ou=inboc-sys,ou=inboc,dc=inboc,dc=net
objectClass: groupOfNames
cn: inboc-sys-senior
member: cn=binchao.tang,ou=inboc-sys,ou=inboc,dc=inboc,dc=net

dn: cn=inboc-sys-junior,ou=inboc-sys,ou=inboc,dc=inboc,dc=net
objectClass: groupOfNames
cn: inboc-sys-junior
member: cn=chao.long,ou=inboc-sys,ou=inboc,dc=inboc,dc=net

dn: cn=inboc-dev-admin,ou=inboc-dev,ou=inboc,dc=inboc,dc=net
objectClass: groupOfNames
cn: inboc-dev-admin
member: cn=cheng.chen,ou=inboc-dev,ou=inboc,dc=inboc,dc=net

dn: cn=inboc-dev-senior,ou=inboc-dev,ou=inboc,dc=inboc,dc=net
objectClass: groupOfNames
cn: inboc-dev-senior
member: cn=xiaofeng.li,ou=inboc-dev,ou=inboc,dc=inboc,dc=net
member: cn=xujun.luo,ou=inboc-dev,ou=inboc,dc=inboc,dc=net

dn: cn=inboc-bod-admin,ou=inboc-bod,ou=inboc,dc=inboc,dc=net
objectClass: groupOfNames
cn: inboc-bod-admin
member: cn=yu.zheng,ou=inboc-bod,ou=inboc,dc=inboc,dc=net


dn: cn=inboc-bus-admin,ou=inboc-bus,ou=inboc,dc=inboc,dc=net
objectClass: groupOfNames
cn: inboc-bus-admin
member: cn=minghong.sun,ou=inboc-bus,ou=inboc,dc=inboc,dc=net
```

执行
```shell
ldapmodify -a -H ldap://ldap01.inboc.net -D "cn=admin,dc=inboc,dc=net" -w Inboc@2020 -f addgroup.ldif
```

查看组
```shell
ldapsearch -H ldapi:/// -x -D "cn=admin,dc=inboc,dc=net" -w Inboc@2020 -b "cn=inboc-sys-admin,ou=inboc-sys,ou=inboc,dc=inboc,dc=net"
```

再来查看entry是否添加了memberof, ldapsearch当不指定字段的时候，默认返回全部强制字段，memberof不属于强制，需要单独指明
```shell
ldapsearch -H ldapi:/// -x -D "cn=admin,dc=inboc,dc=net" -w Inboc@2020 -b "ou=inboc,dc=inboc,dc=net" "(|(cn=jian.xie)(cn=cheng.chen))" memberof
```

可以看到，这两个人都link到了admin组。如此实现了我们的组添加和管理。

同时，再次引入了新的查询语法，filter的正则匹配。
- `(|(cn=ryan.miao)(cn=hr-*))` 表示或者满足某个条件，这里就是为了查询这两个人，另外`*`表示通配符
- `(&(objectClass=inetOrgPerson)(cn=jian.xie))` 第三方系统，比如Python集成ldap的配置，通常会有一个basedn, 就是我们的域名了，然后userfilter,  这个filter就是这个。我们通常填写`objectClass=inetOrgPerson`。然后让我们配置`user_name_attr`, 这就是唯一属性，我们说我们的cn唯一。

所以，一个Python的ldap配置，通常是这个样子的。
```python
[ldap]
# set this to ldaps://<your.ldap.server>:<port>
uri = ldap://172.17.0.2:389
user_filter = objectClass=inetOrgPerson
user_name_attr = cn
group_member_attr = memberof
superuser_filter =
data_profiler_filter =
bind_user = cn=admin,dc=inboc,dc=net
bind_password = admin
basedn = dc=inboc,dc=net
cacert = 
search_scope = SUBTREE
```

### 添加用户到group

我们来创建一个common group， 表示所有人都应该在的一个group。

```shell
# commongroup.sh
dn: cn=g-users,ou=Group,dc=inboc,dc=net
objectClass: groupOfNames
cn: g-users
member: cn=ryan.miao,ou=后台组,ou=研发部门,ou=People,dc=inboc,dc=net
member: cn=hr-ryan,ou=HR,ou=People,dc=inboc,dc=net

ldapmodify -a -H ldap://172.17.0.2:389 -D "cn=admin,dc=inboc,dc=net" -w Inboc@2020 -f commongroup.sh
```

到目前为止，我们添加了2个group：

```shell
# ldapsearch -H ldap:/// -D cn=admin,dc=inboc,dc=net -w Inboc@2020 -b dc=inboc,dc=net -s sub "objectClass=groupOfNames"  dn member
```

接下来，我们把剩下的用户加入到g-users这个group， 以后所有人加入的默认group。

创建addUserToGroup.sh
```avrasm
dn: cn=g-users,ou=Group,dc=inboc,dc=net
changetype: modify
add: member
member: cn=fang.huang,ou=HR,ou=People,dc=inboc,dc=net
member: cn=hr-ryan,ou=HR,ou=People,dc=inboc,dc=net
member: cn=someone,ou=后台组,ou=研发部门,ou=People,dc=inboc,dc=net
member: cn=tester.miao,ou=测试组,ou=研发部门,ou=People,dc=inboc,dc=net
```

执行
```cpp
ldapmodify -H ldap:/// -x -D cn=admin,dc=inboc,dc=net -w Inboc@2020 -f addUserToGroup.sh
```

查看
```avrasm
# ldapsearch -H ldap:/// -D cn=admin,dc=inboc,dc=net -w Inboc@2020 -b dc=inboc,dc=net -s sub "objectClass=groupOfNames"  
```

### 从Group中移除user

inboc-sys-admin 是一个管理员分组，我们去掉普通用户`cn=test,ou=inboc-sys,ou=inboc,dc=inboc,dc=net`

创建removeUserFromGroup.sh
```avrasm
dn: cn=inboc-sys-admin,ou=inboc-sys,ou=inboc,dc=inboc,dc=net
changetype: modify
delete: member
member: cn=test,ou=inboc-sys,ou=inboc,dc=inboc,dc=net
```

执行
```cpp
ldapmodify -H ldap:/// -x -D cn=admin,dc=inboc,dc=net -w Inboc@2020 -f removeUserFromGroup.sh
```

### 最终Group和user的关系

group可以有多个user， user可以归属于多个group，是多对多的关系。

group有多个member字段， user有多个memberof字段。









